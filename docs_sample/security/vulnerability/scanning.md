# Vulnerability Management and Scanning

## 1. Giới thiệu về Vulnerability Management

**Vulnerability** (Lỗ hổng) là một điểm yếu trong hệ thống, quy trình, hoặc kiểm soát có thể bị kẻ tấn công khai thác để gây hại.

**Vulnerability Management** (Quản lý lỗ hổng) là một quy trình liên tục để xác định, phân loại, ưu tiên, khắc phục, và giảm thiểu các lỗ hổng trong hệ thống máy tính, mạng, và ứng dụng. Đây là một trong những trụ cột cơ bản của an toàn thông tin.

### Vòng đời quản lý lỗ hổng

Quy trình này thường bao gồm các bước sau:

1.  **Discover (Khám phá):** Xác định và lập bản đồ tất cả các tài sản (assets) trong môi trường của bạn, bao gồm server, container, ứng dụng, thiết bị mạng, ...
2.  **Scan (Quét):** Sử dụng các công cụ tự động để quét các tài sản này nhằm tìm kiếm các lỗ hổng đã biết (CVEs - Common Vulnerabilities and Exposures).
3.  **Prioritize (Ưu tiên):** Phân tích và ưu tiên các lỗ hổng được tìm thấy dựa trên mức độ nghiêm trọng, khả năng bị khai thác, và tầm quan trọng của tài sản bị ảnh hưởng.
4.  **Remediate (Khắc phục):** Áp dụng các bản vá (patches), thay đổi cấu hình, hoặc các biện pháp khác để loại bỏ lỗ hổng.
5.  **Verify (Xác minh):** Quét lại để xác nhận rằng lỗ hổng đã được khắc phục thành công.
6.  **Report (Báo cáo):** Tạo báo cáo về tình trạng lỗ hổng, tiến trình khắc phục, và các chỉ số hiệu suất chính (KPIs) cho các bên liên quan.

Trong môi trường DevOps, quy trình này cần được tự động hóa và tích hợp chặt chẽ vào chu trình CI/CD để không làm chậm tốc độ phát triển.

## 2. Các loại Vulnerability Scanning

Quét lỗ hổng có thể được thực hiện ở nhiều lớp khác nhau của stack công nghệ.

### a. Phân tích thành phần phần mềm (SCA - Software Composition Analysis)

-   **Mục tiêu:** Quét các thư viện và dependency của bên thứ ba trong mã nguồn ứng dụng của bạn (ví dụ: `package.json`, `pom.xml`, `requirements.txt`).
-   **Tại sao quan trọng:** Các ứng dụng hiện đại phụ thuộc rất nhiều vào các thư viện mã nguồn mở. Một lỗ hổng trong một thư viện nhỏ cũng có thể gây ra rủi ro lớn (ví dụ: Log4Shell).
-   **Công cụ:** Snyk, Dependabot (GitHub), Trivy, Grype.

### b. Phân tích bảo mật tĩnh (SAST - Static Application Security Testing)

-   **Mục tiêu:** Phân tích mã nguồn của ứng dụng (first-party code) để tìm các mẫu code không an toàn có thể dẫn đến lỗ hổng (ví dụ: SQL injection, Cross-Site Scripting - XSS).
-   **Đặc điểm:** Hoạt động giống như một "linter" cho bảo mật. Không cần chạy ứng dụng.
-   **Công cụ:** SonarQube, Checkmarx, Veracode, Snyk Code.

### c. Phân tích bảo mật động (DAST - Dynamic Application Security Testing)

-   **Mục tiêu:** Kiểm tra ứng dụng khi nó đang chạy bằng cách gửi các payload độc hại và phân tích phản hồi để tìm lỗ hổng.
-   **Đặc điểm:** Hoạt động như một "hacker tự động". Nó không cần truy cập vào mã nguồn.
-   **Công cụ:** OWASP ZAP (Zed Attack Proxy), Burp Suite, Acunetix.

### d. Quét Container Image

-   **Mục tiêu:** Quét các lớp của một container image để tìm các lỗ hổng trong các gói của hệ điều hành và các thư viện đã cài đặt.
-   **Công cụ:** Trivy, Grype, Clair, Docker Scout.
-   *(Xem chi tiết trong tài liệu "Container Security: Image Scanning")*

### e. Quét cơ sở hạ tầng (Infrastructure Scanning)

-   **Mục tiêu:** Quét các máy chủ, máy ảo, và các thiết bị mạng để tìm các lỗ hổng ở cấp độ hệ điều hành và dịch vụ mạng.
-   **Công cụ:** Nessus, Qualys, OpenVAS.

### f. Quét cấu hình IaC (IaC Scanning)

-   **Mục tiêu:** Phân tích tĩnh mã nguồn Infrastructure as Code (Terraform, CloudFormation, Kubernetes YAML) để tìm các cấu hình sai có thể tạo ra lỗ hổng.
-   **Công cụ:** Checkov, tfsec, Terrascan, Kube-linter.

## 3. Tích hợp quét lỗ hổng vào CI/CD (DevSecOps)

Mục tiêu của DevSecOps là "shift left" - đưa bảo mật vào giai đoạn sớm nhất có thể trong chu trình phát triển.

![DevSecOps Pipeline](https://i.imgur.com/your-devsecops-pipeline-image.png)  <!-- Placeholder for a real image -->

### Giai đoạn CI (Continuous Integration)

1.  **Pre-commit Hooks:**
    -   Chạy các công cụ quét nhanh như `tfsec` hoặc `gitleaks` (tìm secrets bị commit nhầm) trước khi developer commit code.

2.  **On Pull/Merge Request:**
    -   **SCA:** Chạy Snyk hoặc Dependabot để quét các thư viện của bên thứ ba. GitHub có thể tự động chặn merge nếu phát hiện lỗ hổng nghiêm trọng.
    -   **SAST:** Chạy SonarQube hoặc Snyk Code để phân tích mã nguồn.
    -   **IaC Scan:** Chạy Checkov hoặc tfsec để quét mã nguồn Terraform/Kubernetes.
    -   **Image Scan:** Build container image và quét nó bằng Trivy hoặc Grype.

**Ví dụ Workflow GitHub Actions với Trivy (SCA & Image Scan):**

```yaml
name: "Security Scan"

on:
  pull_request:
    branches: [ main ]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Trivy
        run: |
          # (Các bước cài đặt Trivy)
          sudo apt-get install ... trivy

      # 1. Quét file hệ thống để tìm dependency vulnerabilities (SCA)
      - name: Scan filesystem for vulnerabilities
        run: trivy fs --severity HIGH,CRITICAL --exit-code 1 .

      # 2. Build image
      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .

      # 3. Quét image
      - name: Scan Docker image
        run: trivy image --severity HIGH,CRITICAL --exit-code 1 myapp:${{ github.sha }}
```
Trong workflow này, nếu Trivy tìm thấy bất kỳ lỗ hổng `HIGH` hoặc `CRITICAL` nào trong các dependency hoặc trong container image, nó sẽ thoát với mã lỗi 1, làm cho pipeline thất bại và chặn việc merge code.

### Giai đoạn CD (Continuous Deployment)

1.  **Staging Environment:**
    -   **DAST:** Sau khi triển khai ứng dụng lên môi trường staging, chạy một công cụ DAST (như OWASP ZAP) để quét ứng dụng đang chạy.
    -   **Infrastructure Scan:** Chạy Nessus hoặc OpenVAS để quét các máy chủ trong môi trường staging.

2.  **Production Environment:**
    -   **Continuous Monitoring:** Môi trường production cần được giám sát liên tục.
    -   **Registry Scanning:** Container registry của bạn (ví dụ: Docker Hub, ECR, GCR) nên được cấu hình để tự động quét lại các image khi có một lỗ hổng mới được phát hiện.
    -   **Runtime Security:** Sử dụng các công cụ như Falco để phát hiện các hành vi bất thường trong các container đang chạy.

## 4. Ưu tiên và Khắc phục (Prioritization & Remediation)

Không phải tất cả các lỗ hổng đều có mức độ rủi ro như nhau. Việc cố gắng sửa tất cả mọi thứ ngay lập tức là không thực tế.

### Mô hình chấm điểm

-   **CVSS (Common Vulnerability Scoring System):** Hệ thống chấm điểm tiêu chuẩn (từ 0.0 đến 10.0) dựa trên các yếu tố như vector tấn công, độ phức tạp, yêu cầu đặc quyền, ...
    -   `LOW`: 0.1 - 3.9
    -   `MEDIUM`: 4.0 - 6.9
    -   `HIGH`: 7.0 - 8.9
    -   `CRITICAL`: 9.0 - 10.0
-   **VEX (Vulnerability Exploitability eXchange):** Một tài liệu đi kèm cho biết một sản phẩm có thực sự bị ảnh hưởng bởi một lỗ hổng hay không. Đôi khi, một thư viện có lỗ hổng nhưng ứng dụng của bạn không sử dụng phần code bị lỗi đó.
-   **EPSS (Exploit Prediction Scoring System):** Một hệ thống mới hơn, dự đoán xác suất một lỗ hổng sẽ bị khai thác trong thực tế trong 30 ngày tới.

### Chiến lược ưu tiên

1.  **Lỗ hổng có thể bị khai thác từ xa (Remotely Exploitable):** Ưu tiên cao nhất cho các lỗ hổng có thể bị khai thác qua mạng mà không cần xác thực.
2.  **Lỗ hổng đã có mã khai thác công khai (Public Exploit):** Nếu đã có mã khai thác (exploit code) được công bố, rủi ro bị tấn công sẽ tăng vọt.
3.  **Tầm quan trọng của tài sản:** Một lỗ hổng `MEDIUM` trên một server chứa dữ liệu khách hàng có thể nguy hiểm hơn một lỗ hổng `CRITICAL` trên một server dev không quan trọng.
4.  **Mức độ nghiêm trọng (Severity):** Sử dụng điểm CVSS làm một yếu tố đầu vào, nhưng không phải là yếu tố duy nhất.
5.  **Khả năng khắc phục:** Ưu tiên các lỗ hổng có bản vá dễ dàng.

### Quy trình khắc phục

-   **Thiết lập SLA (Service Level Agreement):** Định nghĩa thời gian tối đa cho phép để khắc phục các lỗ hổng dựa trên mức độ nghiêm trọng của chúng.
    -   `CRITICAL`: 24-48 giờ
    -   `HIGH`: 7-14 ngày
    -   `MEDIUM`: 30 ngày
    -   `LOW`: 90 ngày hoặc khi có cơ hội
-   **Tự động hóa việc tạo ticket:** Tích hợp công cụ quét với hệ thống quản lý công việc (Jira, ServiceNow) để tự động tạo ticket cho các lỗ hổng mới.
-   **Cung cấp hướng dẫn khắc phục:** Báo cáo quét nên bao gồm thông tin chi tiết về cách khắc phục, ví dụ: "nâng cấp thư viện X lên phiên bản Y".
-   **Chấp nhận rủi ro (Risk Acceptance):** Trong một số trường hợp, việc khắc phục có thể không khả thi hoặc quá tốn kém. Cần có một quy trình chính thức để đánh giá và chấp nhận rủi ro, với sự phê duyệt từ cấp quản lý.

Quản lý lỗ hổng là một cuộc chạy marathon, không phải chạy nước rút. Bằng cách xây dựng một quy trình tự động, tích hợp, và dựa trên rủi ro, các nhóm DevOps có thể duy trì tốc độ trong khi vẫn đảm bảo an toàn cho sản phẩm và khách hàng.
